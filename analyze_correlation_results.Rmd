---
title: "Analyze correlation results"
author: "Noor Sohail"
output:
   html_document:
      code_folding: hide
      df_print: paged
      highlights: pygments
      number_sections: true
      self_contained: true
      theme: default
      toc: true
      toc_float:
         collapsed: true
         smooth_scroll: true
---

```{r setup, include=FALSE} 
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
# Turn off Warnings and other console output messages from the whole document
```

```{r, cache=FALSE, message=FALSE}
library(tidyverse)
library(knitr)
library(glue)
library(Seurat)
library(pheatmap)
library(devtools)
library(gridExtra)
library(RColorBrewer)

ggplot2::theme_set(theme_light(base_size = 11))
opts_chunk[["set"]](
    cache = FALSE,
    dev = c("png", "pdf"),
    error = TRUE,
    highlight = TRUE,
    message = FALSE,
    prompt = FALSE,
    tidy = FALSE,
    warning = FALSE)
```


# User define values

```{r}
path_seurat <- "/path/to/seurat.RDS"
path_outs <- "/path/to/results/directory/"

col_sample <- ""
col_celltype <- ""
ct <- ""
```

## Load imputed seurat object

```{r}
filename <- glue("{path_outs}/imputed_{ct}.RDS")
seurat_imputed <- readRDS(filename)
```

Working with `r n_cells` cells.

```{r}
seurat@meta.data %>%
        ggplot() +
        geom_bar(aes(
            x = get(col_sample),
            fill = get(col_sample)),
            stat = "count", color = "black") +
        theme_classic() +
        NoLegend() +
        ggtitle(glue("{ct} cells: Sample distribution")) +
        ylab("Number of Cells") +
        xlab("Sample") +
        theme(plot.title = element_text(hjust = 0.5)) +
        geom_text(aes(x = get(col_sample), label = after_stat(count)), stat = "count", vjust = -0.5) +
        theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

## Load correlation results

```{r}
filename <- glue("{path_outs}/corr_{ct}.csv")
df_corr <- read.csv(filename, row.names=1)
df_p_val <- read.csv(glue("{path_outs}/p_corr_{ct}.csv"), row.names=1)
```


# SAVER and CS-CORE results

Based upon previous results, the results from CS-CORE and SAVER tend to agree with one another which is what we will use to generate the final list of gene pairs.

To make the most informed decision about which gene pairs to use, the final dataframe includes the following information:

- Gene1 and Gene2 (`Var1` and `Var2`)
- SAVER spearman correlation score (`saver`) and p-value (`p_saver`)
- CS-CORE correlation estimate (`cscore`) and p-value (`p_cscore`)
- Average expression for each gene in the pair after SAVER imputation (`Var1_avg` and `Var2_avg`)
- Ratio of average expression (gene 1 average / gene 2 average) (`avg_ratio`)
- Percent cells that express both genes before imputation (`perc_both`) to assess dropout

```{r}
df_results <- df_corr %>% select(Var1, Var2, saver, cscore)

# Including symmetric values
# This will make it easier to see which genes have large differences in average expression
corr_cp <- df_results %>% rename(Var1 = Var2, Var2 = Var1)
df_results <- rbind(df_results, corr_cp)

# Adding p-values for CS-CORE and SAVER
p_corr <- df_p_val %>% select(Var1, Var2, saver, cscore)
colnames(p_corr) <- c("Var1", "Var2", "p_saver", "p_cscore")
p_corr_cp <- p_corr %>% rename(Var1 = Var2, Var2 = Var1)
p_corr <- rbind(p_corr, p_corr_cp)
df_results <- merge(df_results, p_corr)

# Add average SAVER imputed values for each gene
idx <- match(df_results$Var1, df_avg$gene)
df_results$Var1_avg <- df_avg[idx, "saver"]
idx <- match(df_results$Var2, df_avg$gene)
df_results$Var2_avg <- df_avg[idx, "saver"]

# Ratio of average expression values
df_results <- df_results %>% mutate(avg_ratio = Var1_avg / Var2_avg)

data <- as.data.frame(t(data_list[["rna"]]))
df_results$perc_both <- NA
# Percent of cells that express both genes
for (idx in 1:nrow(df_results)) {
    gene_1 <- df_results[idx, "Var1"]
    gene_2 <- df_results[idx, "Var2"]

    data_sub <- data[c(gene_1, gene_2)]
    colnames(data_sub) <- c("Var1", "Var2")
    data_sub <- data_sub %>% subset(!(Var1 == 0) & !(Var2 == 0))
    df_results[idx, "perc_both"] <- nrow(data_sub) / n_cells
}

df_results
```